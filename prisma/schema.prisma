// Prisma Schema - EnVivo
// Database: SQLite (MVP) → PostgreSQL (Production)

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

// ============================================================================
// PREFERENCIAS GLOBALES (NUEVO)
// ============================================================================

model GlobalPreferences {
  id String @id @default("singleton")

  // Ubicación - JSON strings para compatibilidad con SQLite
  allowedCountries String @default("[\"AR\"]") // JSON: ["AR"] - MVP: Solo Argentina
  allowedCities    String @default("[\"Buenos Aires\",\"Ciudad de Buenos Aires\",\"CABA\"]") // JSON: ["Buenos Aires", "Ciudad de Buenos Aires", "CABA"]

  // Géneros musicales - JSON strings
  allowedGenres String @default("[\"Rock\",\"Pop\",\"Jazz\",\"Metal\"]") // JSON: ["Rock", "Pop", "Jazz", "Metal"]
  blockedGenres String @default("[]") // JSON: [] - lista negra opcional

  // Categorías de eventos - JSON string
  allowedCategories String @default("[\"Concierto\",\"Festival\",\"Teatro\"]") // JSON: ["Concierto", "Festival", "Teatro"]

  // Capacidad de venues - JSON strings
  allowedVenueSizes   String @default("[\"small\",\"medium\",\"large\"]") // JSON: ["small", "medium", "large"]
  venueSizeThresholds String @default("{\"small\":500,\"medium\":2000,\"large\":5000}") // JSON object

  // Control de estado
  needsRescraping Boolean  @default(false)
  updatedAt       DateTime @updatedAt
  updatedBy       String? // Para auditoría (opcional)

  @@map("global_preferences")
}

// ============================================================================
// EVENTOS
// ============================================================================

model Event {
  id          String    @id @default(cuid())
  title       String
  description String?
  date        DateTime
  endDate     DateTime?

  // Ubicación
  venueId String?
  venue   Venue?  @relation(fields: [venueId], references: [id])
  city    String
  country String

  // Categorización
  category String  // "Concierto", "Festival", "Teatro"
  genre    String? // "Rock", "Pop", "Jazz"

  // Artistas (relación many-to-many)
  artists EventArtist[]

  // Información adicional
  imageUrl  String?
  ticketUrl String?
  price     Float?
  priceMax  Float?
  currency  String  @default("ARS")

  // Metadatos
  source     String // "allaccess", "eventbrite", "scraper_local"
  externalId String?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  // Índices simples para filtros individuales
  @@index([date])
  @@index([city])
  @@index([category])
  @@index([country])

  // Índices compuestos para combinaciones comunes de filtros
  @@index([city, date]) // Búsqueda: eventos en ciudad X desde fecha Y
  @@index([category, date]) // Búsqueda: festivales desde fecha Y
  @@index([city, category]) // Búsqueda: conciertos en Buenos Aires

  // Índice para deduplicación (source + externalId único)
  @@index([source, externalId])

  // FTS5 se configurará directamente en SQLite en fases posteriores
  @@map("events")
}

// ============================================================================
// VENUES
// ============================================================================

model Venue {
  id       String  @id @default(cuid())
  name     String
  address  String?
  city     String
  country  String
  latitude Float?
  longitude Float?
  capacity Int? // NUEVO: Capacidad del venue (nullable porque no siempre está disponible)
  events   Event[]

  @@index([city])
  @@index([name, city]) // Para búsqueda rápida por nombre y ciudad
  @@map("venues")
}

// ============================================================================
// ARTISTAS
// ============================================================================

model Artist {
  id       String        @id @default(cuid())
  name     String        @unique
  genre    String?
  imageUrl String?
  events   EventArtist[]

  @@map("artists")
}

// ============================================================================
// RELACIÓN MANY-TO-MANY: EVENT ↔ ARTIST
// ============================================================================

model EventArtist {
  eventId  String
  artistId String
  event    Event  @relation(fields: [eventId], references: [id], onDelete: Cascade)
  artist   Artist @relation(fields: [artistId], references: [id], onDelete: Cascade)

  @@id([eventId, artistId])
  @@map("event_artists")
}

// ============================================================================
// VENUE METADATA (Opcional - para enrichment de capacidad)
// ============================================================================
// Esta tabla permite guardar metadata adicional de venues que no viene
// en las APIs/scrapers, como capacidad estimada o verificada manualmente

model VenueMetadata {
  id       String   @id @default(cuid())
  name     String
  city     String
  country  String
  capacity Int?
  source   String // "manual", "api", "estimated"
  verified Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([name, city, country])
  @@index([name, city])
  @@map("venue_metadata")
}

// ============================================================================
// EVENT BLACKLIST (US3.2 - Ocultar Eventos)
// ============================================================================
// Tabla para eventos que el usuario decidió ocultar/eliminar
// Evita que regresen en futuros scrapings usando source + externalId

model EventBlacklist {
  id         String   @id @default(cuid())
  source     String   // "livepass", "allaccess", etc.
  externalId String   // ID del evento en la fuente externa
  reason     String?  // "usuario lo eliminó", "spam", "duplicado", etc.
  createdAt  DateTime @default(now())

  // Índice único para evitar duplicados en blacklist
  @@unique([source, externalId])
  @@index([source, externalId]) // Búsqueda rápida durante scraping
  @@map("event_blacklist")
}
